// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.82.3.
// ignore_for_file: non_constant_identifier_names, unused_element, duplicate_ignore, directives_ordering, curly_braces_in_flow_control_structures, unnecessary_lambdas, slash_for_doc_comments, prefer_const_literals_to_create_immutables, implicit_dynamic_list_literal, duplicate_import, unused_import, unnecessary_import, prefer_single_quotes, prefer_const_constructors, use_super_parameters, always_use_package_imports, annotate_overrides, invalid_use_of_protected_member, constant_identifier_names, invalid_use_of_internal_member, prefer_is_empty, unnecessary_const

import 'bridge_generated.io.dart' if (dart.library.html) 'bridge_generated.web.dart';
import 'dart:convert';
import 'dart:async';
import 'package:meta/meta.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';
import 'package:uuid/uuid.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'package:meta/meta.dart' as meta;
import 'package:collection/collection.dart';

part 'bridge_definitions.freezed.dart';

abstract class FlutterRustBridgeExampleSingleBlockTest {
  /// Documentation on a simple adder function.
  Future<int> simpleAdder({required int a, required int b, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSimpleAdderConstMeta;

  int simpleAdderSync({required int a, required int b, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSimpleAdderSyncConstMeta;

  ///
  /// Multiline comments are fine,
  /// but they are not preferred in Rust nor in Dart.
  /// Newlines are preserved.
  ///
  Future<int> primitiveTypes(
      {required int myI32, required int myI64, required double myF64, required bool myBool, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPrimitiveTypesConstMeta;

  Future<int?> primitiveOptionalTypes({int? myI32, int? myI64, double? myF64, bool? myBool, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPrimitiveOptionalTypesConstMeta;

  int primitiveTypesSync(
      {required int myI32, required int myI64, required double myF64, required bool myBool, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPrimitiveTypesSyncConstMeta;

  Future<int> primitiveU32({required int myU32, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPrimitiveU32ConstMeta;

  int primitiveU32Sync({required int myU32, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPrimitiveU32SyncConstMeta;

  Future<String> handleString({required String s, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleStringConstMeta;

  String handleStringSync({required String s, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleStringSyncConstMeta;

  Future<void> handleReturnUnit({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleReturnUnitConstMeta;

  void handleReturnUnitSync({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleReturnUnitSyncConstMeta;

  Future<Uint8List> handleVecU8({required Uint8List v, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleVecU8ConstMeta;

  Uint8List handleVecU8Sync({required Uint8List v, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleVecU8SyncConstMeta;

  Future<VecOfPrimitivePack> handleVecOfPrimitive({required int n, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleVecOfPrimitiveConstMeta;

  VecOfPrimitivePack handleVecOfPrimitiveSync({required int n, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleVecOfPrimitiveSyncConstMeta;

  Future<ZeroCopyVecOfPrimitivePack> handleZeroCopyVecOfPrimitive({required int n, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleZeroCopyVecOfPrimitiveConstMeta;

  ZeroCopyVecOfPrimitivePack handleZeroCopyVecOfPrimitiveSync({required int n, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleZeroCopyVecOfPrimitiveSyncConstMeta;

  Future<MySize> handleStruct({required MySize arg, required MySize boxed, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleStructConstMeta;

  MySize handleStructSync({required MySize arg, required MySize boxed, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleStructSyncConstMeta;

  MySizeFreezed handleStructSyncFreezed({required MySizeFreezed arg, required MySizeFreezed boxed, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleStructSyncFreezedConstMeta;

  Future<NewTypeInt> handleNewtype({required NewTypeInt arg, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleNewtypeConstMeta;

  NewTypeInt handleNewtypeSync({required NewTypeInt arg, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleNewtypeSyncConstMeta;

  Future<List<MySize>> handleListOfStruct({required List<MySize> l, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleListOfStructConstMeta;

  List<MySize> handleListOfStructSync({required List<MySize> l, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleListOfStructSyncConstMeta;

  Future<List<String>> handleStringList({required List<String> names, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleStringListConstMeta;

  List<String> handleStringListSync({required List<String> names, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleStringListSyncConstMeta;

  Future<MyTreeNode> handleComplexStruct({required MyTreeNode s, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleComplexStructConstMeta;

  MyTreeNode handleComplexStructSync({required MyTreeNode s, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleComplexStructSyncConstMeta;

  Future<MyNestedStruct> handleNestedStruct({required MyNestedStruct s, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleNestedStructConstMeta;

  Uint8List handleSyncReturn({required String mode, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleSyncReturnConstMeta;

  Stream<String> handleStream({required String arg, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleStreamConstMeta;

  Stream<MyStreamEntry> handleStreamOfStruct({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleStreamOfStructConstMeta;

  Future<int> returnErr({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kReturnErrConstMeta;

  Future<int> returnPanic({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kReturnPanicConstMeta;

  Future<double?> handleOptionalReturn({required double left, required double right, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleOptionalReturnConstMeta;

  Future<Element?> handleOptionalStruct({String? document, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleOptionalStructConstMeta;

  Future<ExoticOptionals?> handleOptionalIncrement({ExoticOptionals? opt, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleOptionalIncrementConstMeta;

  Future<double> handleIncrementBoxedOptional({double? opt, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleIncrementBoxedOptionalConstMeta;

  Future<OptVecs> handleVecOfOpts({required OptVecs opt, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleVecOfOptsConstMeta;

  Future<String> handleOptionBoxArguments(
      {int? i8Box,
      int? u8Box,
      int? i32Box,
      int? i64Box,
      double? f64Box,
      bool? boolbox,
      ExoticOptionals? structbox,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleOptionBoxArgumentsConstMeta;

  Future<Uint8List> printNote({required Note note, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPrintNoteConstMeta;

  Future<Weekdays?> handleReturnEnum({required String input, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleReturnEnumConstMeta;

  Future<Weekdays> handleEnumParameter({required Weekdays weekday, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleEnumParameterConstMeta;

  MyEnumFreezed handleEnumSyncFreezed({required MyEnumFreezed value, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleEnumSyncFreezedConstMeta;

  Future<void> handleCustomizedStruct({required Customized val, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleCustomizedStructConstMeta;

  Future<KitchenSink> handleEnumStruct({required KitchenSink val, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleEnumStructConstMeta;

  Future<bool> useImportedStruct({required MyStruct myStruct, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kUseImportedStructConstMeta;

  Future<bool> useImportedEnum({required MyEnum myEnum, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kUseImportedEnumConstMeta;

  Future<ApplicationSettings> getAppSettings({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetAppSettingsConstMeta;

  Future<ApplicationSettings> getFallibleAppSettings({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetFallibleAppSettingsConstMeta;

  Future<bool> isAppEmbedded({required ApplicationSettings appSettings, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kIsAppEmbeddedConstMeta;

  Stream<ApplicationSettings> appSettingsStream({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAppSettingsStreamConstMeta;

  Stream<List<ApplicationSettings>> appSettingsVecStream({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAppSettingsVecStreamConstMeta;

  Stream<MirrorStruct> mirrorStructStream({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kMirrorStructStreamConstMeta;

  Stream<(ApplicationSettings, RawStringEnumMirrored)> mirrorTupleStream({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kMirrorTupleStreamConstMeta;

  Future<ApplicationMessage> getMessage({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetMessageConstMeta;

  Future<Numbers> repeatNumber({required int num, required int times, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kRepeatNumberConstMeta;

  Future<Sequences> repeatSequence({required int seq, required int times, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kRepeatSequenceConstMeta;

  Future<int?> firstNumber({required Numbers nums, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kFirstNumberConstMeta;

  Future<int?> firstSequence({required Sequences seqs, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kFirstSequenceConstMeta;

  Future<U8Array5> getArray({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetArrayConstMeta;

  Future<PointArray2> getComplexArray({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetComplexArrayConstMeta;

  Future<int> getUsize({required int u, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetUsizeConstMeta;

  Future<UserId> nextUserId({required UserId userId, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNextUserIdConstMeta;

  Stream<Event> registerEventListener({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kRegisterEventListenerConstMeta;

  Future<void> closeEventListener({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCloseEventListenerConstMeta;

  Future<void> createEvent({required String address, required String payload, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateEventConstMeta;

  Stream<Log> handleStreamSinkAt1({required int key, required int max, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleStreamSinkAt1ConstMeta;

  Stream<Log> handleStreamSinkAt2({required int key, required int max, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleStreamSinkAt2ConstMeta;

  Stream<Log> handleStreamSinkAt3({required int key, required int max, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleStreamSinkAt3ConstMeta;

  Future<SumWith> getSumStruct({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetSumStructConstMeta;

  Future<SumWithArray3> getSumArray({required int a, required int b, required int c, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetSumArrayConstMeta;

  Future<Measure?> multiplyByTen({required Measure measure, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kMultiplyByTenConstMeta;

  Future<OldSimpleStruct> callOldModuleSystem({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCallOldModuleSystemConstMeta;

  Future<NewSimpleStruct> callNewModuleSystem({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCallNewModuleSystemConstMeta;

  Future<BigBuffers> handleBigBuffers({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleBigBuffersConstMeta;

  Future<DateTime> datetimeUtc({required DateTime d, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDatetimeUtcConstMeta;

  Future<DateTime> datetimeLocal({required DateTime d, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDatetimeLocalConstMeta;

  Future<DateTime> naivedatetime({required DateTime d, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNaivedatetimeConstMeta;

  Future<DateTime?> optionalEmptyDatetimeUtc({DateTime? d, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kOptionalEmptyDatetimeUtcConstMeta;

  Future<Duration> duration({required Duration d, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDurationConstMeta;

  Future<List<Duration>> handleTimestamps({required List<DateTime> timestamps, required DateTime epoch, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleTimestampsConstMeta;

  Future<List<DateTime>> handleDurations({required List<Duration> durations, required DateTime since, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleDurationsConstMeta;

  Future<TestChrono> testChrono({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTestChronoConstMeta;

  Future<TestChrono> testPreciseChrono({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTestPreciseChronoConstMeta;

  Future<Duration> howLongDoesItTake({required FeatureChrono mine, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHowLongDoesItTakeConstMeta;

  Future<UuidValue> handleUuid({required UuidValue id, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleUuidConstMeta;

  Future<List<UuidValue>> handleUuids({required List<UuidValue> ids, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleUuidsConstMeta;

  Future<FeatureUuid> handleNestedUuids({required FeatureUuid ids, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleNestedUuidsConstMeta;

  Future<MessageId> newMsgid({required U8Array32 id, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewMsgidConstMeta;

  Future<U8Array32> useMsgid({required MessageId id, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kUseMsgidConstMeta;

  Future<Blob> boxedBlob({required U8Array1600 blob, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kBoxedBlobConstMeta;

  Future<U8Array1600> useBoxedBlob({required Blob blob, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kUseBoxedBlobConstMeta;

  Future<FeedId> returnBoxedFeedId({required U8Array8 id, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kReturnBoxedFeedIdConstMeta;

  Future<U8Array8> returnBoxedRawFeedId({required FeedId id, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kReturnBoxedRawFeedIdConstMeta;

  Future<TestId> testId({required TestId id, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTestIdConstMeta;

  Future<double> lastNumber({required F64Array16 array, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kLastNumberConstMeta;

  Future<TestIdArray2> nestedId({required TestIdArray4 id, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNestedIdConstMeta;

  String syncAcceptDartOpaque({required Object opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncAcceptDartOpaqueConstMeta;

  Future<String> asyncAcceptDartOpaque({required Object opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAsyncAcceptDartOpaqueConstMeta;

  Future<Object> loopBack({required Object opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kLoopBackConstMeta;

  Future<Object?> loopBackOption({required Object opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kLoopBackOptionConstMeta;

  Future<ObjectArray1> loopBackArray({required Object opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kLoopBackArrayConstMeta;

  Future<List<Object>> loopBackVec({required Object opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kLoopBackVecConstMeta;

  Future<void> loopBackOptionGet({Object? opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kLoopBackOptionGetConstMeta;

  Future<void> loopBackArrayGet({required ObjectArray1 opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kLoopBackArrayGetConstMeta;

  Future<void> loopBackVecGet({required List<Object> opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kLoopBackVecGetConstMeta;

  /// [DartWrapObject] can be safely retrieved on a dart thread.
  String unwrapDartOpaque({required Object opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kUnwrapDartOpaqueConstMeta;

  /// [DartWrapObject] cannot be obtained
  /// on a thread other than the thread it was created on.
  Future<void> panicUnwrapDartOpaque({required Object opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPanicUnwrapDartOpaqueConstMeta;

  Future<HideData> createOpaque({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateOpaqueConstMeta;

  Future<HideData?> createOptionOpaque({HideData? opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateOptionOpaqueConstMeta;

  HideData syncCreateOpaque({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncCreateOpaqueConstMeta;

  Future<EnumOpaqueArray5> createArrayOpaqueEnum({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateArrayOpaqueEnumConstMeta;

  Future<String> runEnumOpaque({required EnumOpaque opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kRunEnumOpaqueConstMeta;

  Future<String> runOpaque({required HideData opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kRunOpaqueConstMeta;

  Future<String> runOpaqueWithDelay({required HideData opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kRunOpaqueWithDelayConstMeta;

  Future<HideDataArray2> opaqueArray({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kOpaqueArrayConstMeta;

  NonCloneData syncCreateNonClone({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncCreateNonCloneConstMeta;

  Future<String> runNonClone({required NonCloneData clone, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kRunNonCloneConstMeta;

  Future<NonSendHideData> createSyncOpaque({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateSyncOpaqueConstMeta;

  NonSendHideData syncCreateSyncOpaque({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncCreateSyncOpaqueConstMeta;

  String syncRunOpaque({required NonSendHideData opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncRunOpaqueConstMeta;

  Future<void> opaqueArrayRun({required HideDataArray2 data, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kOpaqueArrayRunConstMeta;

  Future<List<HideData>> opaqueVec({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kOpaqueVecConstMeta;

  Future<void> opaqueVecRun({required List<HideData> data, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kOpaqueVecRunConstMeta;

  Future<OpaqueNested> createNestedOpaque({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateNestedOpaqueConstMeta;

  Object syncLoopback({required Object opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncLoopbackConstMeta;

  Object? syncOptionLoopback({Object? opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncOptionLoopbackConstMeta;

  String? syncOption({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncOptionConstMeta;

  String? syncOptionNull({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncOptionNullConstMeta;

  HideData? syncOptionRustOpaque({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncOptionRustOpaqueConstMeta;

  Object? syncOptionDartOpaque({required Object opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncOptionDartOpaqueConstMeta;

  void syncVoid({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncVoidConstMeta;

  Future<void> runNestedOpaque({required OpaqueNested opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kRunNestedOpaqueConstMeta;

  Future<DartOpaqueNested> createNestedDartOpaque({required Object opaque1, required Object opaque2, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateNestedDartOpaqueConstMeta;

  Future<void> getNestedDartOpaque({required DartOpaqueNested opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetNestedDartOpaqueConstMeta;

  Future<EnumDartOpaque> createEnumDartOpaque({required Object opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateEnumDartOpaqueConstMeta;

  Future<void> getEnumDartOpaque({required EnumDartOpaque opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetEnumDartOpaqueConstMeta;

  Future<void> setStaticDartOpaque({required Object opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSetStaticDartOpaqueConstMeta;

  Future<void> dropStaticDartOpaque({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDropStaticDartOpaqueConstMeta;

  Future<String> unwrapRustOpaque({required HideData opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kUnwrapRustOpaqueConstMeta;

  Object returnNonDroppableDartOpaque({required Object opaque, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kReturnNonDroppableDartOpaqueConstMeta;

  /// Function to check the code generator.
  /// FrbOpaqueReturn must be only return type.
  /// FrbOpaqueReturn must not be used as an argument.
  Future<FrbOpaqueReturn> frbGeneratorTest({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kFrbGeneratorTestConstMeta;

  /// Structure for testing the SyncReturn<RustOpaque> code generator.
  /// FrbOpaqueSyncReturn must be only return type.
  /// FrbOpaqueSyncReturn must be without wrapper like Option<> Vec<> etc.
  FrbOpaqueSyncReturn frbSyncGeneratorTest({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kFrbSyncGeneratorTestConstMeta;

  Future<int> handleTypeAliasId({required int input, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleTypeAliasIdConstMeta;

  Future<int> handleTypeNestAliasId({required int input, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleTypeNestAliasIdConstMeta;

  Future<TestModel> handleTypeAliasModel({required int input, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleTypeAliasModelConstMeta;

  Future<Empty> emptyStruct({required Empty empty, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kEmptyStructConstMeta;

  Future<dynamic> returnDartDynamic({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kReturnDartDynamicConstMeta;

  Future<RawStringItemStruct> testRawStringItemStruct({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTestRawStringItemStructConstMeta;

  Future<MoreThanJustOneRawStringStruct> testMoreThanJustOneRawStringStruct({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTestMoreThanJustOneRawStringStructConstMeta;

  Future<RawStringMirrored> testRawStringMirrored({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTestRawStringMirroredConstMeta;

  Future<NestedRawStringMirrored> testNestedRawStringMirrored({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTestNestedRawStringMirroredConstMeta;

  Future<RawStringEnumMirrored> testRawStringEnumMirrored({required bool nested, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTestRawStringEnumMirroredConstMeta;

  Future<ListOfNestedRawStringMirrored> testListOfRawNestedStringMirrored({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTestListOfRawNestedStringMirroredConstMeta;

  Future<List<RawStringMirrored>> testFallibleOfRawStringMirrored({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTestFallibleOfRawStringMirroredConstMeta;

  Future<List<Weekdays>> listOfPrimitiveEnums({required List<Weekdays> weekdays, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kListOfPrimitiveEnumsConstMeta;

  Future<Abc> testAbcEnum({required Abc abc, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTestAbcEnumConstMeta;

  Future<ContainsMirroredSubStruct> testContainsMirroredSubStruct({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTestContainsMirroredSubStructConstMeta;

  Future<StructWithEnum> testStructWithEnum({required StructWithEnum se, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTestStructWithEnumConstMeta;

  Future<(String, int)> testTuple({(String, int)? value, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTestTupleConstMeta;

  Future<void> testTuple2({required List<(String, int)> value, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTestTuple2ConstMeta;

  ApplicationSettings syncReturnMirror({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncReturnMirrorConstMeta;

  Future<MacroStruct> macroStruct({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kMacroStructConstMeta;

  Future<int> returnErrCustomError({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kReturnErrCustomErrorConstMeta;

  Future<int> returnOkCustomError({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kReturnOkCustomErrorConstMeta;

  Future<int> returnErrorVariant({required int variant, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kReturnErrorVariantConstMeta;

  Future<void> returnCustomNestedError1({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kReturnCustomNestedError1ConstMeta;

  Future<void> returnCustomNestedError1Variant1({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kReturnCustomNestedError1Variant1ConstMeta;

  Future<void> returnCustomNestedError2({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kReturnCustomNestedError2ConstMeta;

  Future<void> returnCustomStructError({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kReturnCustomStructErrorConstMeta;

  void syncReturnCustomStructError({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncReturnCustomStructErrorConstMeta;

  Future<int> returnCustomStructOk({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kReturnCustomStructOkConstMeta;

  Future<void> throwAnyhow({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kThrowAnyhowConstMeta;

  Future<void> panicWithCustomResult({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPanicWithCustomResultConstMeta;

  Stream<String> streamSinkThrowAnyhow({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kStreamSinkThrowAnyhowConstMeta;

  Future<String> asStringMethodEvent({required Event that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAsStringMethodEventConstMeta;

  Future<int> sumMethodSumWith({required SumWith that, required int y, required int z, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSumMethodSumWithConstMeta;

  /// Documentation on a static method
  Future<ConcatenateWith> newStaticMethodConcatenateWith({required String a, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewStaticMethodConcatenateWithConstMeta;

  /// Documentation on an instance method
  Future<String> concatenateMethodConcatenateWith({required ConcatenateWith that, required String b, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kConcatenateMethodConcatenateWithConstMeta;

  Future<String> concatenateStaticStaticMethodConcatenateWith({required String a, required String b, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kConcatenateStaticStaticMethodConcatenateWithConstMeta;

  Stream<Log2> handleSomeStreamSinkMethodConcatenateWith(
      {required ConcatenateWith that, required int key, required int max, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleSomeStreamSinkMethodConcatenateWithConstMeta;

  Stream<int> handleSomeStreamSinkAt1MethodConcatenateWith({required ConcatenateWith that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleSomeStreamSinkAt1MethodConcatenateWithConstMeta;

  Stream<Log2> handleSomeStaticStreamSinkStaticMethodConcatenateWith(
      {required int key, required int max, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleSomeStaticStreamSinkStaticMethodConcatenateWithConstMeta;

  Stream<int> handleSomeStaticStreamSinkSingleArgStaticMethodConcatenateWith({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHandleSomeStaticStreamSinkSingleArgStaticMethodConcatenateWithConstMeta;

  Future<SomeStruct> newStaticMethodSomeStruct({required int value, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewStaticMethodSomeStructConstMeta;

  Future<int> staticReturnErrCustomErrorStaticMethodSomeStruct({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kStaticReturnErrCustomErrorStaticMethodSomeStructConstMeta;

  Future<int> staticReturnOkCustomErrorStaticMethodSomeStruct({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kStaticReturnOkCustomErrorStaticMethodSomeStructConstMeta;

  Future<int> nonStaticReturnErrCustomErrorMethodSomeStruct({required SomeStruct that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNonStaticReturnErrCustomErrorMethodSomeStructConstMeta;

  Future<int> nonStaticReturnOkCustomErrorMethodSomeStruct({required SomeStruct that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNonStaticReturnOkCustomErrorMethodSomeStructConstMeta;

  Future<CustomStruct> newStaticMethodCustomStruct({required String message, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewStaticMethodCustomStructConstMeta;

  Future<void> staticReturnCustomStructErrorStaticMethodCustomStruct({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kStaticReturnCustomStructErrorStaticMethodCustomStructConstMeta;

  Future<int> staticReturnCustomStructOkStaticMethodCustomStruct({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kStaticReturnCustomStructOkStaticMethodCustomStructConstMeta;

  Future<void> nonstaticReturnCustomStructErrorMethodCustomStruct({required CustomStruct that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNonstaticReturnCustomStructErrorMethodCustomStructConstMeta;

  Future<int> nonstaticReturnCustomStructOkMethodCustomStruct({required CustomStruct that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNonstaticReturnCustomStructOkMethodCustomStructConstMeta;

  DropFnType get dropOpaqueBoxDartDebug;
  ShareFnType get shareOpaqueBoxDartDebug;
  OpaqueTypeFinalizer get BoxDartDebugFinalizer;

  DropFnType get dropOpaqueFrbOpaqueReturn;
  ShareFnType get shareOpaqueFrbOpaqueReturn;
  OpaqueTypeFinalizer get FrbOpaqueReturnFinalizer;

  DropFnType get dropOpaqueFrbOpaqueSyncReturn;
  ShareFnType get shareOpaqueFrbOpaqueSyncReturn;
  OpaqueTypeFinalizer get FrbOpaqueSyncReturnFinalizer;

  DropFnType get dropOpaqueHideData;
  ShareFnType get shareOpaqueHideData;
  OpaqueTypeFinalizer get HideDataFinalizer;

  DropFnType get dropOpaqueI32;
  ShareFnType get shareOpaqueI32;
  OpaqueTypeFinalizer get I32Finalizer;

  DropFnType get dropOpaqueMutexHideData;
  ShareFnType get shareOpaqueMutexHideData;
  OpaqueTypeFinalizer get MutexHideDataFinalizer;

  DropFnType get dropOpaqueNonCloneData;
  ShareFnType get shareOpaqueNonCloneData;
  OpaqueTypeFinalizer get NonCloneDataFinalizer;

  DropFnType get dropOpaqueNonSendHideData;
  ShareFnType get shareOpaqueNonSendHideData;
  OpaqueTypeFinalizer get NonSendHideDataFinalizer;

  DropFnType get dropOpaqueRwLockHideData;
  ShareFnType get shareOpaqueRwLockHideData;
  OpaqueTypeFinalizer get RwLockHideDataFinalizer;
}

@sealed
class BoxDartDebug extends FrbOpaque {
  final FlutterRustBridgeExampleSingleBlockTest bridge;
  BoxDartDebug.fromRaw(int ptr, int size, this.bridge) : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueBoxDartDebug;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueBoxDartDebug;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.BoxDartDebugFinalizer;
}

class EnumOpaqueArray5 extends NonGrowableListView<EnumOpaque> {
  static const arraySize = 5;
  EnumOpaqueArray5(List<EnumOpaque> inner)
      : assert(inner.length == arraySize),
        super(inner);
  EnumOpaqueArray5.unchecked(List<EnumOpaque> inner) : super(inner);
  EnumOpaqueArray5.init(EnumOpaque fill) : super(List<EnumOpaque>.filled(arraySize, fill));
}

@sealed
class FrbOpaqueReturn extends FrbOpaque {
  final FlutterRustBridgeExampleSingleBlockTest bridge;
  FrbOpaqueReturn.fromRaw(int ptr, int size, this.bridge) : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueFrbOpaqueReturn;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueFrbOpaqueReturn;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.FrbOpaqueReturnFinalizer;
}

@sealed
class FrbOpaqueSyncReturn extends FrbOpaque {
  final FlutterRustBridgeExampleSingleBlockTest bridge;
  FrbOpaqueSyncReturn.fromRaw(int ptr, int size, this.bridge) : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueFrbOpaqueSyncReturn;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueFrbOpaqueSyncReturn;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.FrbOpaqueSyncReturnFinalizer;
}

@sealed
class HideData extends FrbOpaque {
  final FlutterRustBridgeExampleSingleBlockTest bridge;
  HideData.fromRaw(int ptr, int size, this.bridge) : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueHideData;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueHideData;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.HideDataFinalizer;
}

class HideDataArray2 extends NonGrowableListView<HideData> {
  static const arraySize = 2;
  HideDataArray2(List<HideData> inner)
      : assert(inner.length == arraySize),
        super(inner);
  HideDataArray2.unchecked(List<HideData> inner) : super(inner);
  HideDataArray2.init(HideData fill) : super(List<HideData>.filled(arraySize, fill));
}

@sealed
class I32 extends FrbOpaque {
  final FlutterRustBridgeExampleSingleBlockTest bridge;
  I32.fromRaw(int ptr, int size, this.bridge) : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueI32;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueI32;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.I32Finalizer;
}

@sealed
class MutexHideData extends FrbOpaque {
  final FlutterRustBridgeExampleSingleBlockTest bridge;
  MutexHideData.fromRaw(int ptr, int size, this.bridge) : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueMutexHideData;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueMutexHideData;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.MutexHideDataFinalizer;
}

@sealed
class NonCloneData extends FrbOpaque {
  final FlutterRustBridgeExampleSingleBlockTest bridge;
  NonCloneData.fromRaw(int ptr, int size, this.bridge) : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueNonCloneData;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueNonCloneData;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.NonCloneDataFinalizer;
}

@sealed
class NonSendHideData extends FrbOpaque {
  final FlutterRustBridgeExampleSingleBlockTest bridge;
  NonSendHideData.fromRaw(int ptr, int size, this.bridge) : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueNonSendHideData;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueNonSendHideData;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.NonSendHideDataFinalizer;
}

class ObjectArray1 extends NonGrowableListView<Object> {
  static const arraySize = 1;
  ObjectArray1(List<Object> inner)
      : assert(inner.length == arraySize),
        super(inner);
  ObjectArray1.unchecked(List<Object> inner) : super(inner);
  ObjectArray1.init(Object fill) : super(List<Object>.filled(arraySize, fill));
}

class PointArray2 extends NonGrowableListView<Point> {
  static const arraySize = 2;
  PointArray2(List<Point> inner)
      : assert(inner.length == arraySize),
        super(inner);
  PointArray2.unchecked(List<Point> inner) : super(inner);
  PointArray2.init(Point fill) : super(List<Point>.filled(arraySize, fill));
}

@sealed
class RwLockHideData extends FrbOpaque {
  final FlutterRustBridgeExampleSingleBlockTest bridge;
  RwLockHideData.fromRaw(int ptr, int size, this.bridge) : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueRwLockHideData;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueRwLockHideData;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.RwLockHideDataFinalizer;
}

class SumWithArray3 extends NonGrowableListView<SumWith> {
  static const arraySize = 3;
  SumWithArray3(List<SumWith> inner)
      : assert(inner.length == arraySize),
        super(inner);
  SumWithArray3.unchecked(List<SumWith> inner) : super(inner);
  SumWithArray3.init(SumWith fill) : super(List<SumWith>.filled(arraySize, fill));
}

class TestIdArray2 extends NonGrowableListView<TestId> {
  static const arraySize = 2;
  TestIdArray2(List<TestId> inner)
      : assert(inner.length == arraySize),
        super(inner);
  TestIdArray2.unchecked(List<TestId> inner) : super(inner);
  TestIdArray2.init(TestId fill) : super(List<TestId>.filled(arraySize, fill));
}

class TestIdArray4 extends NonGrowableListView<TestId> {
  static const arraySize = 4;
  TestIdArray4(List<TestId> inner)
      : assert(inner.length == arraySize),
        super(inner);
  TestIdArray4.unchecked(List<TestId> inner) : super(inner);
  TestIdArray4.init(TestId fill) : super(List<TestId>.filled(arraySize, fill));
}

class A {
  final String a;

  const A({
    required this.a,
  });
}

@freezed
sealed class Abc with _$Abc {
  const factory Abc.a(
    A field0,
  ) = Abc_A;
  const factory Abc.b(
    B field0,
  ) = Abc_B;
  const factory Abc.c(
    C field0,
  ) = Abc_C;
  const factory Abc.justInt(
    int field0,
  ) = Abc_JustInt;
}

class ApplicationEnv {
  final List<ApplicationEnvVar> vars;

  const ApplicationEnv({
    required this.vars,
  });
}

class ApplicationEnvVar {
  final String field0;
  final bool field1;

  const ApplicationEnvVar({
    required this.field0,
    required this.field1,
  });
}

@freezed
sealed class ApplicationMessage with _$ApplicationMessage {
  const factory ApplicationMessage.displayMessage(
    String field0,
  ) = ApplicationMessage_DisplayMessage;
  const factory ApplicationMessage.renderPixel({
    required int x,
    required int y,
  }) = ApplicationMessage_RenderPixel;
  const factory ApplicationMessage.exit() = ApplicationMessage_Exit;
}

enum ApplicationMode {
  standalone,
  embedded,
}

class ApplicationSettings {
  final String name;
  final String version;
  final ApplicationMode mode;
  final ApplicationEnv env;
  final ApplicationEnv? envOptional;

  const ApplicationSettings({
    required this.name,
    required this.version,
    required this.mode,
    required this.env,
    this.envOptional,
  });
}

class Attribute {
  final String key;
  final String value;

  const Attribute({
    required this.key,
    required this.value,
  });
}

class B {
  final int b;

  const B({
    required this.b,
  });
}

class BigBuffers {
  final Int64List int64;
  final Uint64List uint64;

  const BigBuffers({
    required this.int64,
    required this.uint64,
  });
}

class Blob {
  final U8Array1600 field0;

  const Blob({
    required this.field0,
  });
}

class C {
  final bool c;

  const C({
    required this.c,
  });
}

class ConcatenateWith {
  final FlutterRustBridgeExampleSingleBlockTest bridge;
  final String a;

  const ConcatenateWith({
    required this.bridge,
    required this.a,
  });

  /// Documentation on a static method
  static Future<ConcatenateWith> newConcatenateWith(
          {required FlutterRustBridgeExampleSingleBlockTest bridge, required String a, dynamic hint}) =>
      bridge.newStaticMethodConcatenateWith(a: a, hint: hint);

  /// Documentation on an instance method
  Future<String> concatenate({required String b, dynamic hint}) => bridge.concatenateMethodConcatenateWith(
        that: this,
        b: b,
      );

  static Future<String> concatenateStatic(
          {required FlutterRustBridgeExampleSingleBlockTest bridge,
          required String a,
          required String b,
          dynamic hint}) =>
      bridge.concatenateStaticStaticMethodConcatenateWith(a: a, b: b, hint: hint);

  Stream<Log2> handleSomeStreamSink({required int key, required int max, dynamic hint}) =>
      bridge.handleSomeStreamSinkMethodConcatenateWith(
        that: this,
        key: key,
        max: max,
      );

  Stream<int> handleSomeStreamSinkAt1({dynamic hint}) => bridge.handleSomeStreamSinkAt1MethodConcatenateWith(
        that: this,
      );

  static Stream<Log2> handleSomeStaticStreamSink(
          {required FlutterRustBridgeExampleSingleBlockTest bridge,
          required int key,
          required int max,
          dynamic hint}) =>
      bridge.handleSomeStaticStreamSinkStaticMethodConcatenateWith(key: key, max: max, hint: hint);

  static Stream<int> handleSomeStaticStreamSinkSingleArg(
          {required FlutterRustBridgeExampleSingleBlockTest bridge, dynamic hint}) =>
      bridge.handleSomeStaticStreamSinkSingleArgStaticMethodConcatenateWith(hint: hint);
}

class ContainsMirroredSubStruct {
  final RawStringMirrored test;
  final A test2;

  const ContainsMirroredSubStruct({
    required this.test,
    required this.test2,
  });
}

@freezed
sealed class CustomError with _$CustomError implements FrbException {
  @Implements<FrbBacktracedException>()
  const factory CustomError.error0({
    required String e,
    required String backtrace,
  }) = CustomError_Error0;
  @Implements<FrbBacktracedException>()
  const factory CustomError.error1({
    required int e,
    required String backtrace,
  }) = CustomError_Error1;
}

@freezed
sealed class CustomNestedError1 with _$CustomNestedError1 implements FrbException {
  const factory CustomNestedError1.customNested1(
    String field0,
  ) = CustomNestedError1_CustomNested1;
  const factory CustomNestedError1.errorNested(
    CustomNestedError2 field0,
  ) = CustomNestedError1_ErrorNested;
}

@freezed
sealed class CustomNestedError2 with _$CustomNestedError2 {
  const factory CustomNestedError2.customNested2(
    String field0,
  ) = CustomNestedError2_CustomNested2;
  const factory CustomNestedError2.customNested2Number(
    int field0,
  ) = CustomNestedError2_CustomNested2Number;
}

class CustomStruct {
  final FlutterRustBridgeExampleSingleBlockTest bridge;
  final String message;

  const CustomStruct({
    required this.bridge,
    required this.message,
  });

  static Future<CustomStruct> newCustomStruct(
          {required FlutterRustBridgeExampleSingleBlockTest bridge, required String message, dynamic hint}) =>
      bridge.newStaticMethodCustomStruct(message: message, hint: hint);

  static Future<void> staticReturnCustomStructError(
          {required FlutterRustBridgeExampleSingleBlockTest bridge, dynamic hint}) =>
      bridge.staticReturnCustomStructErrorStaticMethodCustomStruct(hint: hint);

  static Future<int> staticReturnCustomStructOk(
          {required FlutterRustBridgeExampleSingleBlockTest bridge, dynamic hint}) =>
      bridge.staticReturnCustomStructOkStaticMethodCustomStruct(hint: hint);

  Future<void> nonstaticReturnCustomStructError({dynamic hint}) =>
      bridge.nonstaticReturnCustomStructErrorMethodCustomStruct(
        that: this,
      );

  Future<int> nonstaticReturnCustomStructOk({dynamic hint}) => bridge.nonstaticReturnCustomStructOkMethodCustomStruct(
        that: this,
      );
}

class CustomStructError implements FrbException {
  final String message;

  const CustomStructError({
    required this.message,
  });
}

class Customized {
  final String finalField;
  String? nonFinalField;

  Customized({
    required this.finalField,
    this.nonFinalField,
  });
}

class DartOpaqueNested {
  final Object first;
  final Object second;

  const DartOpaqueNested({
    required this.first,
    required this.second,
  });
}

@freezed
sealed class Distance with _$Distance {
  const factory Distance.unknown() = Distance_Unknown;
  const factory Distance.map(
    double field0,
  ) = Distance_Map;
}

class Element {
  final String? tag;
  final String? text;
  final List<Attribute>? attributes;
  final List<Element>? children;

  const Element({
    this.tag,
    this.text,
    this.attributes,
    this.children,
  });
}

class Empty {
  const Empty();
}

@freezed
sealed class EnumDartOpaque with _$EnumDartOpaque {
  const factory EnumDartOpaque.primitive(
    int field0,
  ) = EnumDartOpaque_Primitive;
  const factory EnumDartOpaque.opaque(
    Object field0,
  ) = EnumDartOpaque_Opaque;
}

@freezed
sealed class EnumOpaque with _$EnumOpaque {
  const factory EnumOpaque.struct(
    HideData field0,
  ) = EnumOpaque_Struct;
  const factory EnumOpaque.primitive(
    I32 field0,
  ) = EnumOpaque_Primitive;
  const factory EnumOpaque.traitObj(
    BoxDartDebug field0,
  ) = EnumOpaque_TraitObj;
  const factory EnumOpaque.mutex(
    MutexHideData field0,
  ) = EnumOpaque_Mutex;
  const factory EnumOpaque.rwLock(
    RwLockHideData field0,
  ) = EnumOpaque_RwLock;
}

@freezed
class Event with _$Event {
  const Event._();
  const factory Event({
    required FlutterRustBridgeExampleSingleBlockTest bridge,
    required String address,
    required String payload,
  }) = _Event;
  Future<String> asString({dynamic hint}) => bridge.asStringMethodEvent(
        that: this,
      );
}

class ExoticOptionals {
  final int? int32;
  final int? int64;
  final double? float64;
  final bool? boolean;
  final Uint8List? zerocopy;
  final Int8List? int8List;
  final Uint8List? uint8List;
  final Int32List? int32List;
  final Float32List? float32List;
  final Float64List? float64List;
  final List<Attribute>? attributes;
  final List<Attribute?> attributesNullable;
  final List<Attribute?>? nullableAttributes;
  final NewTypeInt? newtypeint;

  const ExoticOptionals({
    this.int32,
    this.int64,
    this.float64,
    this.boolean,
    this.zerocopy,
    this.int8List,
    this.uint8List,
    this.int32List,
    this.float32List,
    this.float64List,
    this.attributes,
    required this.attributesNullable,
    this.nullableAttributes,
    this.newtypeint,
  });
}

class F64Array16 extends NonGrowableListView<double> {
  static const arraySize = 16;
  F64Array16(Float64List inner)
      : assert(inner.length == arraySize),
        super(inner);
  F64Array16.unchecked(Float64List inner) : super(inner);
  F64Array16.init() : super(Float64List(arraySize));
}

class FeatureChrono {
  final DateTime utc;
  final DateTime local;
  final Duration duration;
  final DateTime naive;

  const FeatureChrono({
    required this.utc,
    required this.local,
    required this.duration,
    required this.naive,
  });
}

class FeatureUuid {
  final UuidValue one;
  final List<UuidValue> many;

  const FeatureUuid({
    required this.one,
    required this.many,
  });
}

class FeedId {
  final U8Array8 field0;

  const FeedId({
    required this.field0,
  });
}

class I32Array2 extends NonGrowableListView<int> {
  static const arraySize = 2;
  I32Array2(Int32List inner)
      : assert(inner.length == arraySize),
        super(inner);
  I32Array2.unchecked(Int32List inner) : super(inner);
  I32Array2.init() : super(Int32List(arraySize));
}

@freezed
sealed class KitchenSink with _$KitchenSink {
  /// Comment on variant
  const factory KitchenSink.empty() = KitchenSink_Empty;
  const factory KitchenSink.primitives({
    /// Dart field comment
    @Default(-1) int int32,
    required double float64,
    required bool boolean,
  }) = KitchenSink_Primitives;
  const factory KitchenSink.nested(
    int field0, [
    @Default(KitchenSink.empty()) KitchenSink field1,
  ]) = KitchenSink_Nested;
  const factory KitchenSink.optional([
    /// Comment on anonymous field
    @Default(-1) int? field0,
    int? field1,
  ]) = KitchenSink_Optional;
  const factory KitchenSink.buffer(
    Uint8List field0,
  ) = KitchenSink_Buffer;
  const factory KitchenSink.enums([
    @Default(Weekdays.sunday) Weekdays field0,
  ]) = KitchenSink_Enums;
}

class ListOfNestedRawStringMirrored {
  final List<NestedRawStringMirrored> raw;

  const ListOfNestedRawStringMirrored({
    required this.raw,
  });
}

class Log {
  final int key;
  final int value;

  const Log({
    required this.key,
    required this.value,
  });
}

class Log2 {
  final int key;
  final String value;

  const Log2({
    required this.key,
    required this.value,
  });
}

class MacroStruct {
  final int data;
  int nonFinalData;

  MacroStruct({
    required this.data,
    required this.nonFinalData,
  });
}

@freezed
sealed class Measure with _$Measure {
  const factory Measure.speed(
    Speed field0,
  ) = Measure_Speed;
  const factory Measure.distance(
    Distance field0,
  ) = Measure_Distance;
}

class MessageId {
  final U8Array32 field0;

  const MessageId({
    required this.field0,
  });
}

class MirrorStruct {
  final ApplicationSettings a;
  final MyStruct b;
  final List<MyEnum> c;
  final List<ApplicationSettings> d;

  const MirrorStruct({
    required this.a,
    required this.b,
    required this.c,
    required this.d,
  });
}

class MoreThanJustOneRawStringStruct {
  final String regular;
  final String type;
  final bool async;
  final String another;

  const MoreThanJustOneRawStringStruct({
    required this.regular,
    required this.type,
    required this.async,
    required this.another,
  });
}

enum MyEnum {
  False,
  True,
}

@freezed
sealed class MyEnumFreezed with _$MyEnumFreezed {
  const factory MyEnumFreezed.a(
    int field0,
  ) = MyEnumFreezed_A;
  const factory MyEnumFreezed.b(
    String field0,
  ) = MyEnumFreezed_B;
}

class MyNestedStruct {
  final MyTreeNode treeNode;
  final Weekdays weekday;

  const MyNestedStruct({
    required this.treeNode,
    required this.weekday,
  });
}

class MySize {
  final int width;
  final int height;

  const MySize({
    required this.width,
    required this.height,
  });
}

@freezed
class MySizeFreezed with _$MySizeFreezed {
  const factory MySizeFreezed({
    required int width,
    required int height,
  }) = _MySizeFreezed;
}

class MyStreamEntry {
  final String hello;

  const MyStreamEntry({
    required this.hello,
  });
}

class MyStruct {
  final bool content;

  const MyStruct({
    required this.content,
  });
}

class MyTreeNode {
  final int valueI32;
  final Uint8List valueVecU8;
  final bool valueBoolean;
  final List<MyTreeNode> children;

  const MyTreeNode({
    required this.valueI32,
    required this.valueVecU8,
    required this.valueBoolean,
    required this.children,
  });
}

class NestedRawStringMirrored {
  final RawStringMirrored raw;

  const NestedRawStringMirrored({
    required this.raw,
  });
}

class NewSimpleStruct {
  final int field;

  const NewSimpleStruct({
    required this.field,
  });
}

class NewTypeInt {
  final int field0;

  const NewTypeInt({
    required this.field0,
  });
}

class Note {
  final Weekdays day;
  final String body;

  const Note({
    this.day = Weekdays.sunday,
    required this.body,
  });
}

class Numbers {
  final Int32List field0;

  const Numbers({
    required this.field0,
  });
}

class OldSimpleStruct {
  final int field;

  const OldSimpleStruct({
    required this.field,
  });
}

/// [`HideData`] has private fields.
class OpaqueNested {
  final HideData first;
  final HideData second;

  const OpaqueNested({
    required this.first,
    required this.second,
  });
}

class OptVecs {
  final List<int?> i32;
  final List<Weekdays?> enums;
  final List<String?> strings;
  final List<Int32List?> buffers;

  const OptVecs({
    required this.i32,
    required this.enums,
    required this.strings,
    required this.buffers,
  });
}

class Point {
  final double x;
  final double y;

  const Point({
    required this.x,
    required this.y,
  });
}

@freezed
sealed class RawStringEnumMirrored with _$RawStringEnumMirrored {
  const factory RawStringEnumMirrored.raw(
    RawStringMirrored field0,
  ) = RawStringEnumMirrored_Raw;
  const factory RawStringEnumMirrored.nested(
    NestedRawStringMirrored field0,
  ) = RawStringEnumMirrored_Nested;
  const factory RawStringEnumMirrored.listOfNested(
    ListOfNestedRawStringMirrored field0,
  ) = RawStringEnumMirrored_ListOfNested;
}

class RawStringItemStruct {
  final String type;

  const RawStringItemStruct({
    required this.type,
  });
}

class RawStringMirrored {
  final String value;

  const RawStringMirrored({
    required this.value,
  });
}

class Sequences {
  final Int32List field0;

  const Sequences({
    required this.field0,
  });
}

class SomeStruct {
  final FlutterRustBridgeExampleSingleBlockTest bridge;
  final int value;

  const SomeStruct({
    required this.bridge,
    required this.value,
  });

  static Future<SomeStruct> newSomeStruct(
          {required FlutterRustBridgeExampleSingleBlockTest bridge, required int value, dynamic hint}) =>
      bridge.newStaticMethodSomeStruct(value: value, hint: hint);

  static Future<int> staticReturnErrCustomError(
          {required FlutterRustBridgeExampleSingleBlockTest bridge, dynamic hint}) =>
      bridge.staticReturnErrCustomErrorStaticMethodSomeStruct(hint: hint);

  static Future<int> staticReturnOkCustomError(
          {required FlutterRustBridgeExampleSingleBlockTest bridge, dynamic hint}) =>
      bridge.staticReturnOkCustomErrorStaticMethodSomeStruct(hint: hint);

  Future<int> nonStaticReturnErrCustomError({dynamic hint}) => bridge.nonStaticReturnErrCustomErrorMethodSomeStruct(
        that: this,
      );

  Future<int> nonStaticReturnOkCustomError({dynamic hint}) => bridge.nonStaticReturnOkCustomErrorMethodSomeStruct(
        that: this,
      );
}

@freezed
sealed class Speed with _$Speed {
  const factory Speed.unknown() = Speed_Unknown;
  const factory Speed.gps(
    double field0,
  ) = Speed_GPS;
}

class StructWithEnum {
  final Abc abc1;
  final Abc abc2;

  const StructWithEnum({
    required this.abc1,
    required this.abc2,
  });
}

class SumWith {
  final FlutterRustBridgeExampleSingleBlockTest bridge;
  final int x;

  const SumWith({
    required this.bridge,
    required this.x,
  });

  Future<int> sum({required int y, required int z, dynamic hint}) => bridge.sumMethodSumWith(
        that: this,
        y: y,
        z: z,
      );
}

class TestChrono {
  final DateTime? dt;
  final DateTime? dt2;
  final Duration? du;

  const TestChrono({
    this.dt,
    this.dt2,
    this.du,
  });
}

class TestId {
  final I32Array2 field0;

  const TestId({
    required this.field0,
  });
}

class TestModel {
  final int id;
  final String name;
  final MyEnum aliasEnum;
  final MyStruct aliasStruct;

  const TestModel({
    required this.id,
    required this.name,
    required this.aliasEnum,
    required this.aliasStruct,
  });
}

class U8Array1600 extends NonGrowableListView<int> {
  static const arraySize = 1600;
  U8Array1600(Uint8List inner)
      : assert(inner.length == arraySize),
        super(inner);
  U8Array1600.unchecked(Uint8List inner) : super(inner);
  U8Array1600.init() : super(Uint8List(arraySize));
}

class U8Array32 extends NonGrowableListView<int> {
  static const arraySize = 32;
  U8Array32(Uint8List inner)
      : assert(inner.length == arraySize),
        super(inner);
  U8Array32.unchecked(Uint8List inner) : super(inner);
  U8Array32.init() : super(Uint8List(arraySize));
}

class U8Array5 extends NonGrowableListView<int> {
  static const arraySize = 5;
  U8Array5(Uint8List inner)
      : assert(inner.length == arraySize),
        super(inner);
  U8Array5.unchecked(Uint8List inner) : super(inner);
  U8Array5.init() : super(Uint8List(arraySize));
}

class U8Array8 extends NonGrowableListView<int> {
  static const arraySize = 8;
  U8Array8(Uint8List inner)
      : assert(inner.length == arraySize),
        super(inner);
  U8Array8.unchecked(Uint8List inner) : super(inner);
  U8Array8.init() : super(Uint8List(arraySize));
}

/// Example for @freezed and @meta.immutable
@freezed
@meta.immutable
class UserId with _$UserId {
  const factory UserId({
    @Default(0) int value,
  }) = _UserId;
}

class VecOfPrimitivePack {
  final Int8List int8List;
  final Uint8List uint8List;
  final Int16List int16List;
  final Uint16List uint16List;
  final Uint32List uint32List;
  final Int32List int32List;
  final Uint64List uint64List;
  final Int64List int64List;
  final Float32List float32List;
  final Float64List float64List;
  final List<bool> boolList;

  const VecOfPrimitivePack({
    required this.int8List,
    required this.uint8List,
    required this.int16List,
    required this.uint16List,
    required this.uint32List,
    required this.int32List,
    required this.uint64List,
    required this.int64List,
    required this.float32List,
    required this.float64List,
    required this.boolList,
  });
}

/// Simple enums.
enum Weekdays {
  monday,
  tuesday,
  wednesday,
  thursday,
  friday,

  /// Best day of the week.
  saturday,
  sunday,
}

class ZeroCopyVecOfPrimitivePack {
  final Int8List int8List;
  final Uint8List uint8List;
  final Int16List int16List;
  final Uint16List uint16List;
  final Uint32List uint32List;
  final Int32List int32List;
  final Uint64List uint64List;
  final Int64List int64List;
  final Float32List float32List;
  final Float64List float64List;

  const ZeroCopyVecOfPrimitivePack({
    required this.int8List,
    required this.uint8List,
    required this.int16List,
    required this.uint16List,
    required this.uint32List,
    required this.int32List,
    required this.uint64List,
    required this.int64List,
    required this.float32List,
    required this.float64List,
  });
}
